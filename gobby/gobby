!obby
session version="0.4.5"
 user_table
  user colour="ccccff" id="1" name="spec"
  user colour="7fe176" id="2" name="phon"
 chat
  system_message text="spec has joined" timestamp="1253644867"
  system_message text="phon has joined" timestamp="1253644910"
  user_message text="moo" timestamp="1253644919" user="2"
  user_message text="mooo" timestamp="1253644923" user="2"
  user_message text="cool :)" timestamp="1253644925" user="1"
  user_message text="muh" timestamp="1253644926" user="2"
  system_message text="spec has created a new document: Fourk" timestamp="1253644938"
  user_message text="I'm back in a minute or two" timestamp="1253645921" user="2"
  user_message text="back" timestamp="1253646017" user="2"
  user_message text="ok no problem:)" timestamp="1253646030" user="1"
 document encoding="UTF-8" id="1" owner="1" suffix="1" title="Fourk"
  chunk author="1" content=":)\nok let's start with the stuff...\n"
  chunk author="2" content="for sure, urgh.. my color is too strong\nbetter.."
  chunk author="1" content="\n\n1. Architecture\nthat what was said before\nand...how do we tackle the immediate/compiling and normal words couple\nnormally we would have two pointers for each mode, compile and the interpret mode\nfor each word, but that seems to be an overkill\n"
  chunk author="2" content="\nah, now I see. got it from the wrong point. \n"
  chunk author="1" content="we need some kind of polymorphism for compilation and interpretation it is \na detail but important"
  chunk author="2" content="\n\nSo the word layout we talk about looks normally like this:\n\n-------------\n    name\n-------------\n    type ptr\n-------------\n  \"code\" ptr\n-------------\n   (next ptr)   // which will be useless in our case\n-------------\n"
  chunk author="1" content="\nyes, but.. type ptr is really a couple: compilation semantics and interpretation \nsemantics \n(which are pointers usually to compile and interpret words), so intepreter pushes the word on stack and executes one of them\n"
  chunk author="2" content="\nI saw different layouts. btw. that is the actual layout I use in my forth.\n\nThe type of the word is saved in a flag.\n"
  chunk author="1" content="Yes that is another solution, that was the case in my first forth\nbut apparently in case of an image you need only one field whatever it is !\nbecause you are not intepreting at this time\nyou don't even need any field really...\ni am greedy to strip anything i can you see\n\n"
  chunk author="2" content="no wonder, we target 4k. so we need to.\n"
  chunk author="1" content="\nso is it reasoanble to encode this information somewher else?\nthat would easier our lives\n"
  chunk author="2" content="\nI'm a bit unsure about which information we are talking about?\nAbout the behaviour of the word? if it's imediate or not?\n"
  chunk author="1" content="\nyes\nthere is another thing\n"
  chunk author="2" content="which is actually just compiler sugar(imediate words)\n"
  chunk author="1" content="yes, but if we plan to strip any information from the image, we need to be able to partition the image into sections\nif we are not planning any relocation, otherwise we can backpatch the image at runtime\n"
  chunk author="2" content="\n\"backpatch\"? means what?\n"
  chunk author="1" content="\nyes fix the addresses at a runtime\nif i had such code in the core:\n\nmovl\t$ntab,%ebp\n...\n\nand then change the image such that real ntab address in the image will be different\ni need to alter this instruction and update the address\n(which will happen always when we change the layout)\n\n2. Image layout\n"
  chunk author="2" content="\nhmm.."
  chunk author="1" content="\nWe need to think what would be the simpliest way\nmy proposal is:\n(i need to resemble that)\n\n-------------------------------------\n* start marker \n  run module              - allow to run the vm with an image\n  dynamic symbols load    - loads the symbols at the runtime (imports)\n  core dictionary         - all the assemly words not immediate\t  \n  user dictionary         - our defined words not immediate\n  word ptr table          - dispatch table with word pointers\n  word symbol name table  - import table\n\n* erase marker begin           - beg here everything will be erased\n      word name table          - \n      interpret/compile module \n      imm ptr table\n imm dictionary\n      data space\n      \n* erase marker end\n\n"
  chunk author="2" content="Q: That is the memory layout? looks like that\nA: "
  chunk author="1" content="yes\n\nQ: How we are going to fill the gaps in dispatch table, because it can contain \npointers to words which will be stripped off (immediate ones) and we are adressing\nwith an index, so it must be continous region? (or we don't care about it? just zeroes? or RLE) \n"
  chunk author="2" content="\nQ: If I see that correctly, we have two tables for wordnames. One for\n   words and the other for import symbols, do we need that?\n"
  chunk author="1" content="A: A good point, maybe special flag is enough? The importing will be done in \na brute force way, just harcoded lib name and will try to import a symbol from each one \nuntil it finds it, so we will have e.g glutOpenWindow (or whathever) and look also in\nlibgl and then in libGLUT. so we need only names. OK that is fine to have special flag to do it. Cool idea:).\nBut... again we are stripping the name table for runtime... because we don't need any names in the image... :(\n\n"
  chunk author="2" content="Q: Ok, what is the actual problem? we need some compact format, without \n   all that names. Is that what we need? I see it that way."
  chunk author="1" content="\nA: Yes, generally speaking we need to be able to get rid of some parts of executable with minimal runtime costs.\n   (Including code to handle that, and space needed)\n"
  chunk author="2" content="\nThe costs are what we are interested in. ok.\n"
  chunk author="1" content="I have thoughts about ifs and butts in the image. Maybe we can shift it to postprocess the image. \nRelocate some of the sections and so on, that will be more clever. Because I originally thought to leave.. \nzeores in the image and let the compressor do the job. \n\nQ: How did you make the image loader for the BootForth and GameForth?\n"
  chunk author="2" content="A: Simple, that isn't done yet :-(\n"
  chunk author="1" content="Ah ok it is not that easy!\nQ: Any fresh thought what shall we do currently, how do we split a code? I can say that some of the parts \nare done. Simple interpreter and three words. "
  chunk author="2" content="\nQQ: Split the code? making it smaller? "
  chunk author="1" content="\nAA: No just dividing the work :) So we both will be happy and busy:)\n"
  chunk author="2" content="At the moment I don't have an idea and I'm a bit tired. must be that \ngit-repo-battle"
  chunk author="1" content="\n\nOK. Yes I see, thanks for that once more. So what I will do tonight I will add some features."
  chunk author="2" content="\nPlaying a bit around with some possible ways could lead to the best solution or\natleast the more realistic one.\n\n"
  chunk author="1" content="Maybe you can try to run it, on your machine.\n(should work flawlessly as it is small)\nthe words suported, \"+\", \"drop\", \"dup\", \".\" :)\n \n"
  chunk author="2" content="The Image needs a place like a main or something like that, which gets executed\nat startup.\n\nFrom the primitve side, which are basically bytecodes in that threading system,\nwe need followingd: \n\n- something for getting a window"
  chunk author="1" content=" (glut or SDL)"
  chunk author="2" content="\n- something for opengl/whatever"
  chunk author="1" content=" (openGL)"
  chunk author="2" content="\n- sound"
  chunk author="1" content=" (/dev/snd"
  chunk author="2" content=" "
  chunk author="1" content=" )"
  chunk author="2" content=" (better interface)"
  chunk author="1" content=" (SDL again?)"
  chunk author="2" content=" perhaps? don't know"
  chunk author="1" content=" (yes, I am sure)"
  chunk author="2" content="\n- something for closing the window (SDL again)"
  chunk author="1" content=" (yes)"
  chunk author="2" content="\n"
  chunk author="1" content="\n\n\nIn my previous version it used to be like that\n\n1.0 1.0 1.0 glVertex3f **"
  chunk author="2" content="\nwhat did the ** \n"
  chunk author="1" content="just called the address on the stack\noh and i had also the size to fix the stack frame... (maybe it was already in the glVertex3f)\nbut i see big point of having uniform representation of words and imports\n"
  chunk author="2" content="\"plug and play\"?"
  chunk author="1" content="\nYes, maybe to make an import table we will need to recompile Fourk!\n"
  chunk author="2" content="\n"
  chunk author="1" content="\nYes, last defined word will do."
  chunk author="2" content="\nHmm? in what context will that do it?\n\n\n"
  chunk author="1" content="------------\n3. Imports\n------------\n"
  chunk author="2" content="\n"