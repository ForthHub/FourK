create ; 
       postpone lit 1 c, postpone state postpone !
       postpone last 
       postpone @ 
       postpone lit 
       1 c, 
       postpone + 
       postpone last 
       postpone ! 

       postpone lit
       -1 c,
       postpone here 
       postpone @
       postpone c!

       -1 c, 
       
immediate

last @ 1 + last ! 

create : 
       postpone create 
       postpone lit 
       0 c, 
       postpone state 
       postpone ! 
;

: [ 1 state ! ; immediate
: ] 0 state ! ;

: here@ here @ ;
: literal 0 c, c, ;
: rliteral 1 c, , ;

: begin here@ ; immediate
: repeat postpone branch here@ - c, immediate ;

: a begin 1 . 10 emit repeat ;

: if postpone branch0 here@ 0 c, ; immediate
: then dup here@ swap - swap c! ; immediate 

: [char] key literal ; immediate

: | begin key 10 = if ;; then repeat ; immediate


| TODO:
| we need to stay with line comments and shift below for later
| to make nesting possible with some loops

: 1+ 1 + ;
: 1- 1 - ;
: 0= 0 = ;

: a [char] A . ;


: ( 1
    begin
	[char] ) key dup rot = if swap 1- dup 0= if drop drop ;; then swap then
	[char] (             = if 1+ then
    repeat ; immediate

( ( a b c ) )

: 2dup swap dup rot dup rot swap ;

: (* begin key 42 = if key 41 = if ;; then then repeat ; immediate


| comparison words
: <> = invert ;
: 0<> 0= invert ;
: <= > invert ;
: >= < invert ;
: +! swap >r dup @ r> + swap ! ;

: data: here there @ here@ there ! swap ! ;
: data; data: ;

| output words
: cr 10 emit ;

: unhide last 1+! ;

| === a test routine === 
| : a 0 begin 1 + repeat ;

: a begin repeat ;
| a


: create create there @ rliteral postpone ;; unhide ; 

| image saver 
| save-image image.4ki

| to verbose but will make optimisations later
| by default we will use byte cells, as it is meant to be 4kb tool
: cell 1 ;
: cells cell * ;
| ref cells
: rcell 4 ;
: rcells rcell * ;
: rcells+ rcells + ;

: allot there @ + there ! ;

: variable : there @ rliteral postpone ; rcell allot  ;


: r ( -- r ) postpone r> postpone dup postpone >r ; immediate

| strings 
: " ( -- str c ) here @ >r there @ here ! 0 >r 
  begin key dup 34 = if 0 c, drop there @ r> here @ there ! r> here ! ;; then 
  c, r> 1 + >r repeat
; immediate

: "" begin 1 . repeat ;

: t 0 >r r> drop ;

: type ( str c -- ) >r begin 
  r 0= if r> drop drop ;; then 
  r> 1 - >r dup c@ emit 1 + repeat 
; 

: ccall: : postpone ccall c, postpone ; ;

0 ccall: dlopen
1 ccall: dlsym
2 ccall: printf

: >cstr drop ;

: lib >cstr 1 swap dlopen ;
: sym >cstr swap dlsym ;


: l lib ;

" libc.so.6" lib " printf" sym

ithere @ 4 rcells+ !
4 ithere @ 5 rcells+ !


" FourK interaction started." >cstr printf cr
