create ;
postpone lit 1 c, postpone state postpone !
postpone last
postpone @
postpone lit
1 c,
postpone +
postpone last
postpone !

postpone lit
-1 c,
postpone here
postpone @
postpone c!

postpone lit
-1 c,
postpone here
postpone @
postpone lit
1 c,
postpone +
postpone c!

immediate

last @ 1 + last !

create :
       postpone create
       postpone lit
       0 c,
       postpone state
       postpone !
;

: [ 1 state ! ; immediate
: ] 0 state ! ;

: here@ here @ ;

: literal 0 c, c, ;
: rliteral 1 c, , ;
: sliteral swap rliteral literal ;

: 2dup swap dup rot dup rot swap ;

: 1+ 1 + ;
: 1- 1 - ;
: 0= 0 = ;
: cr 10 emit ;
: space 32 emit ;
: . . space ;

: begin here@ ; immediate

: repeat postpone branch here@ - c, immediate ;
: until  postpone branch0 here@ - c, ; immediate

: if postpone branch0 here@ 0 c, ; immediate
: then dup here@ swap - swap  c! ; immediate

: | begin key 10 = if ;; then repeat ; immediate

: c: key state @ 0 = if literal then ; immediate

: ( 1
    begin
	c: ) key dup rot = if swap 1- dup 0= if drop drop ;; then swap then
	c: (             = if 1+ then
    repeat ; immediate


: (* begin key c: * = if key c: ) = if ;; then then repeat ; immediate

(*
a multi
line
comment
*)

| comparison words
: <> = invert ;
: 0<> 0= invert ;
: <= > invert ;
: >= < invert ;
: +! swap >r dup @ r> + swap ! ;

: data: here there @ here@ there ! swap ! ;
: data; data: ;

| output words


: create create there @ rliteral postpone ; ;

| to verbose but will make optimisations later
| by default we will use byte cells, as it is meant to be 4kb tool
: cell 1 ;
: cells cell * ;
| ref cells
: rcell 4 ;
: rcells rcell * ;
: rcells+ rcells + ;

: allot there @ + there ! ;

: variable : there @ rliteral postpone ; rcell allot  ;
: const : rliteral postpone ; ;


: r ( -- r ) postpone r> postpone dup postpone >r ; immediate

| strings

create #str
256 allot


: parse ( delimiter -- str c ) [ there @ rliteral ] c! here @ >r #str here !
  begin key dup [ there @ rliteral ] c@ = if drop #str here @ #str - 0 c, r> here ! ;; then
  c, repeat
;
1 allot

: " c: " parse ; immediate


| inlines a counted list of bytes to there
: inline ( str c -- str c ) here @ >r there @ here ! here @ + >r
  begin r here @ = if drop there @ r> there @ - here @ there ! r> here ! ;; then
  dup c@ c, 1+ repeat
;

: t 0 >r r> drop ;

: type ( str c -- ) >r begin
  r 0 = if r> drop drop ;; then
  r> 1 - >r dup c@ emit 1+ repeat
;


| pimped ", it now compiles the string to there @compile time
: " postpone " state @ 0 = if inline there @ dup 0 swap c! 1+ there !
   sliteral then
; immediate

: ." postpone " state @ 0 = if postpone type ;; then type ; immediate


: ccall: : postpone ccall c, postpone ; ;

0 ccall: dlopen
1 ccall: dlsym

: >cstr drop ;

: lib >cstr $2 swap dlopen ;

: sym >cstr swap dlsym ;

variable #ithere
4 #ithere !

: add-handle ( handle stackfix -- )
  ithere @ 1 #ithere @ + rcells+ !
  ithere @ #ithere @ rcells+ !
  #ithere @ 2 + #ithere !
;



| do loops

: do
    postpone swap
    postpone >r
    postpone >r
    postpone begin
; immediate


: loop
    postpone r>
    postpone dup
    postpone 1+
    postpone r
    postpone swap
    postpone >r
    postpone =
    postpone until
    postpone r>
    postpone r>
    postpone drop
    postpone drop
; immediate

: type' 1- 0 do dup r + c@ emit loop ;

: i postpone r ; immediate

: j postpone r>
    postpone r>
    postpone r> 
    postpone dup
    postpone >r
    postpone swap
    postpone >r
    postpone swap
    postpone >r
; immediate


