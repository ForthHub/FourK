: inc ( adr -- ) dup @ 1+ swap ! ;
: dec ( adr -- ) dup @ 1- swap ! ;

: 2drop ( n n -- ) drop drop ; 
: over ( a b -- a b a ) swap dup >r swap r> ;
: 2dup ( a b -- a b a b ) over over ;

| exit current word if TOS is zero
: 0; ( n -- ) postpone = postpone if 
              postpone ;; postpone then 
; immediate 


: next-set ( char-adr char-adr -- ) 1+ swap 1+ swap ;
: ch@ ( char-adr char-adr -- t/f ) c@ swap c@ ;

variable flag
| compare two zero terminated strings, the strings are assumed to be 
| of the same size (no size checking ) 
: compare ( str str -- t/f ) -1 flag ! 
  begin 
   2dup ch@ 2dup = invert if 0 flag ! then 
   and 0 = if 2drop flag @ ;; then next-set 
  repeat 
;

| compare two counted strings ( so with size checking ) 
: str= ( str c str c -- t/f ) >r swap r> = if compare ;; then 0 ;

| count the given zero-terminated string
: count ( str -- c ) 0 >r 
  begin dup c@ 0 = if drop r> ;; then 1+ r> 1+ >r repeat 
;

variable last-symbol

create symbols
1024 allot

symbols last-symbol ! 

: symbol" ( -- ) 
  c: " parse there @ >r last-symbol @ there !
  1+ inline there @ last-symbol ! r> there ! 0 last-symbol @ 1+ c!
;
: next-symbol ( symbol -- symbol+1 ) 
  dup count + 1+ 
; 
: search ( str c -- index ) 0 >r symbols >r
  begin 
   2dup r count 0 = if r> 2drop 2drop r> 2drop 0 ;; then 
   r dup count str= if 2drop r> drop r> ;; then 
   r> next-symbol r> 1+ >r >r r r count type cr  
  repeat 
;


symbol" foo"
symbol" your-father"
symbol" your-mother"

: moo 1 1 = if 5 . then  ;
moo
