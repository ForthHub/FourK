
: inc ( adr -- ) dup @ 1+ swap ! ;
: dec ( adr -- ) dup @ 1- swap ! ;

| exit current word if TOS is zero
: 0; ( n -- ) postpone = postpone if 
              postpone ;; postpone then 
; immediate 


: next-set ( char-adr char-adr -- ) 1+ swap 1+ swap ;
: ch@ ( char-adr char-adr -- t/f ) c@ swap c@ ;

variable flag
| compare two zero terminated strings, the strings are assumed to be 
| of the same size (no size checking ) 
: compare ( str str -- t/f ) -1 flag ! 
  begin 
   2dup ch@ 2dup = invert if 0 flag ! then 
   and 0 = if 2drop flag @ ;; then next-set 
  repeat 
;

| compare two counted strings ( so with size checking ) 
: str= ( str c str c -- t/f ) >r swap r> = if compare ;; then 2drop 0 ;

| count the given zero-terminated string
: count ( str -- c ) 0 >r 
  begin dup c@ 0 = if drop r> ;; then 1+ r> 1+ >r repeat 
;


variable last-symbol


create symbols
1024 allot

symbols last-symbol ! 




: symbol ( str c -- ) 
  there @ >r last-symbol @ there !  
  1+ inline 2drop there @ last-symbol ! r> there ! 0 last-symbol @ 1+ c!
;
: symbol" ( -- ) c: " parse symbol ;

: next-symbol ( symbol -- symbol+1 ) 
  dup count + 1+ 
; 
: search ( str c -- index ) 0 >r symbols >r
  begin
   2dup r count 0 = if r> 2drop 2drop r> 2drop -1 ;; then 
   r dup count str= if 2drop r> drop r> ;; then 
    r> next-symbol r> 1+ >r >r   
  repeat 
;


variable library 

symbol" dlopen"
symbol" dlsym"

: lib" ( -- ) c: " parse lib library ! ;
: func" ( stackfix  -- ) library @ c: " parse 2dup symbol sym add-handle ;

: x" c: " parse search ;



lib" libc.so.6"
rcell func" printf"
x" printf"


| a marker?
: marker? ( str c -- t|f ) " *marker*" str= ;
| get name for token n
: name> ( n -- str c ) 32 * ntab @ + dup count ;

: mark ( -- ) " *marker*" drop make postpone ; ;

| little alias to make 4k.el mode happier
: again repeat ;

: forget ( -- )
    last @ 1-
    begin
	dup name> marker?
	if
	    dup last ! rcells vtab @ + @ here ! ;;
	then
	dup 0 = if cr drop ;; then
	1-
    again
;
