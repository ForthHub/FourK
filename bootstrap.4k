token ; make

postpone lit 1 c,
postpone state
postpone !

postpone last
postpone @
postpone lit 1 c,
postpone +
postpone last
postpone !

postpone lit
-1 c,
postpone here
postpone @
postpone lit
0 c,
postpone +
postpone c!

postpone lit
-2 c,
postpone here
postpone @
postpone lit
1 c,
postpone +

postpone c!

immediate

last @ 1 + last !

token : make
    postpone token
    postpone make
    postpone lit
    0 c,
    postpone state
    postpone !
;




: [ 1 state ! ; immediate
: ] 0 state ! ;




: here@ here @ ;


: literal 0 c, c, ;
: rliteral 1 c, , ;
: sliteral swap rliteral literal ;
: allot there @ + there ! ;
: rcell 4 ;
: rcells rcell * ;
: rcells+ rcells + ;

: create token make there @ rliteral postpone ; ;
: variable : there @ rliteral postpone ; rcell allot ;
: const : rliteral postpone ; ;
variable #section
0 #section !
create table 16 32 * allot


: 2dup swap dup rot dup rot swap ;


: 1+ 1 + ;
: 1- 1 - ;
: 0= 0 = ;
: cr 10 emit ;
: space 32 emit ;
: . . space ;

: begin here@ ; immediate

: repeat postpone branch here@ - c, immediate ;
: until  postpone branch0 here@ - c, ; immediate

: if postpone branch0 here@ 0 c, ; immediate
: then dup here@ swap - swap  c! ; immediate
: else >r postpone branch here@ 0 c, r> postpone then ; immediate

: | begin key 10 = if ;; then repeat ; immediate


| Taking into account prefix word
 : ; -1 here @ c! -2 here @ 1+ c! last @ 1+ last !
  last @ 253 = if 256 last ! then postpone [ ; immediate


: c: key state @ 0 = if literal then ; immediate


: ( 1
    begin
	c: ) key dup rot = if swap 1- dup 0= if drop drop ;; then swap then
	c: (             = if 1+ then

    repeat ; immediate


: (* begin key c: * = if key c: ) = if ;; then then repeat ; immediate

(*
a multi
line
comment
*)

| moved from strings.4k
: 2drop ( n n -- ) drop drop ; 
: over ( a b -- a b a ) swap dup >r swap r> ;
: 2dup ( a b -- a b a b ) over over ;

| comparison words
: <> = invert ;
: 0<> 0= invert ;
: <= > invert ;
: >= < invert ;
: +! swap >r dup @ r> + swap ! ;
: 1+! 1 +! ;
: data: here there @ here@ there ! swap ! ;
: data; data: ;

| output words




| to verbose but will make optimisations later
| by default we will use byte cells, as it is meant to be 4kb tool
: cell 1 ;
: cells cell * ;
| ref cells



: r ( -- r ) postpone r> postpone dup postpone >r ; immediate




| strings

create #str
256 allot


: parse ( delimiter -- str c ) [ there @ rliteral ] c! here @ >r #str here !
  begin key dup [ there @ rliteral ] 
  c@ = if drop #str here @ #str - 0 c, r> here ! ;; then
  c, repeat
;
1 allot

: \" c: " parse ;
| "

| inlines a counted list of bytes to there
: inline ( str c -- str c ) 
  here @ >r there @ here ! here @ + >r
  begin r here @ = if drop there @ r> there @ - here @ there ! r> here ! ;; then
  dup c@ c, 1+ repeat
;

: t 0 >r r> drop ;

: type ( str c -- ) >r begin
  r 0 = if r> drop drop ;; then
  r> 1 - >r dup c@ emit 1+ repeat
;


: inc ( adr -- ) dup @ 1+ swap ! ;
: dec ( adr -- ) dup @ 1- swap ! ;

| exit current word if TOS is zero
: 0; ( n -- ) postpone = postpone if 
              postpone ;; postpone then 
; immediate 


: next-set ( char-adr char-adr -- ) 1+ swap 1+ swap ;
: ch@ ( char-adr char-adr -- t/f ) c@ swap c@ ;

variable flag
| compare two zero terminated strings, the strings are assumed to be 
| of the same size (no size checking ) 
: compare ( str str -- t/f ) -1 flag ! 
  begin 
   2dup ch@ 2dup = invert if 0 flag ! then 
   and 0 = if 2drop flag @ ;; then next-set 
  repeat 
;

| compare two counted strings ( so with size checking ) 
: str= ( str c str c -- t/f ) >r swap r> = if compare ;; then 2drop 0 ;


| pimped ", it now compiles the string to there @compile time
: " \" state @ 0 = if inline there @ dup 0 swap c! 1+ there !
   sliteral then
; immediate


| : ." ( -- ) postpone " 
| state @ 0 = if postpone type ;; then type 
| ; immediate


: ccall: : postpone ccall c, postpone ; ;

0 ccall: dlopen
1 ccall: dlsym

: >cstr drop ;

: lib >cstr $2 swap dlopen ;

: sym >cstr swap dlsym ;

variable #ithere

4 #ithere !

: add-handle ( handle stackfix -- )
|  ." index: " #ithere @ 2 / . cr 
 | over 0 = if ." ERROR: handle is 0" cr 2drop ;; then over ." handle: " . cr 
  ithere @ 1 #ithere @ + rcells+ !
  ithere @ #ithere @ rcells+ !
  #ithere @ 2 + #ithere !
;





| do loops

: do
    postpone swap
    postpone >r
    postpone >r
    postpone begin
; immediate

: leave postpone r> postpone r> postpone drop postpone drop ; immediate

: loop
    postpone r>
    postpone dup
    postpone 1+
    postpone r
    postpone swap
    postpone >r
    postpone =
    postpone until
    postpone r>
    postpone r>
    postpone drop
    postpone drop
; immediate

: type' 1- 0 do dup r + c@ emit loop ;

: i postpone r ; immediate

: j postpone r>
    postpone r>
    postpone r> 
    postpone dup
    postpone >r
    postpone swap
    postpone >r
    postpone swap
    postpone >r
; immediate

: include" \" include ; immediate
| Hmmmm this does inteerupt compiling
-1 const c-1
| "    
| : require" \" over over find -1 = if over over make postpone ; include ;; then ." File " type ."  already provided." cr ;
: require" \" over over find -1 = if over over make postpone ; include ;; then  ;




| little alias to make 4k.el mode happier
: again postpone repeat ; immediate

| count the given zero-terminated string
: count ( str -- c ) 0 >r 
  begin dup c@ 0 = if drop r> ;; then 1+ r> 1+ >r repeat 
;

: words ( -- )
    last @ 1-
    begin
	dup 32 * ntab @ + dup count type space
	dup 0 = if cr drop ;; then
	1-
    again
;


: inc ( ptr1 ptr2 c -- ptr1 ptr2 ) dup rot + swap rot + swap ;

| Not 100% correct (but works with overlapping blocks )
| @spec, what does this thing do??? 
: cmove> ( src dst c -- )
    >r 2dup <
    if
	2dup swap r + <
	if
	    r 1- inc
	    begin r> dup 0 = if drop r> drop drop drop ;; then 1- >r 2dup swap c@ swap c! -1 inc again
	then
    then
    begin r> dup 0 = if drop r> drop drop drop ;; then 1- >r 2dup swap c@ swap c! 1 inc again
;


: copy ( src c dst -- ) 
  there @ >r there ! inline 2drop r> there ! 
;


| "
: there: ( -- )  here there @ here @ there ! swap ! ; 
: ;there ( -- )  there here @ there @ here ! swap ! ; 

(*
	Sections, lenght 32 bytes 
	----------------------
	| string < 1-23 byte > + 1 Byte |
	| offset < 4 byte >   | 
	| pointer < 4 byte>  | 
	----------------------
*)


| Sections support
32 const section
: th section * ;
: :pointer ( section -- adr-ptr ) section + rcell - ;
: :offset ( section -- adr-offset ) :pointer rcell - ; 
: 1+! ( -- ) 1 swap +! ;
: in ( -- ) + ;
: new ( str c -- ) 
  1+ #section @ th table in 
  dup :pointer there @ swap ! #section 1+! copy 
;
: forall ( -- max min ) #section @ 0 ; 


: dump ( -- ) forall do i th table in dup count type cr loop ;
: mark ( -- )  here @ there @ 
  " *marker*" make rliteral rliteral postpone ; 
; immediate
: forget ( -- ) 
  " *marker*" find 
  dup -1 <> if dup last ! execute there ! here ! 
  -1 here @ c! -1 -2 here @ 1+ c! ;; then drop 
;
: section ( -- ) token new ;

: find-section ( str c -- index )
   forall do 2dup i th table in dup 
   count str= if 2drop i leave ;; then loop -1 
;
: section-adr ( str c -- adr-of-section ) find-section th table in ;

: there! ( element -- oldthere ) th table in :pointer @ there @ swap there ! ;


: section: ( -- ) 
  token find-section literal postpone dup postpone >r 
  postpone there! postpone >r 
; immediate
: update-offset ( section -- ) th table in dup :pointer @ there @ swap - swap :offset ! ;
: ;section ( -- ) 
  postpone r> postpone r> postpone update-offset 
  postpone there postpone ! 
; immediate

section data
64 allot



